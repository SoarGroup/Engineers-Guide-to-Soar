"""This file separates our Soar event callbacks for App4"""

import random

import Python_sml_ClientInterface as sml

from suppliersort_course.Project10_SML.app4.instructor_solution_io import (
    MyAgentInputManager, 
    parse_supplier_list, read_ol_supplier_list
)

#########################################################################
# Soar Event Callback Functions:

# STEP 2: Define the callback function for the print event
def callback_print(event_id, user_data, agent, message:str):
    """Callback to pick up any CLI output generated by the agent"""
    m = message.strip()
    if not m[0].isdigit():
        print(m)

# STEP 4: Define the callback function for the run events
#   It should respond to two events: Before any run starts, and before every input phase.
#   1) Before a run starts, generate 6 random suppliers as input for the agent.
#   2) Before every input phase, print a "*" character to show we caught the event properly.
def callback_run(event_id, input_manager:MyAgentInputManager, agent, phase):
    """Callback to pick up any run events"""
    # EVENT 1: Before Any Run Starts
    if event_id == sml.smlEVENT_BEFORE_RUN_STARTS:
        # Don't generate input if the agent just interrupted itself,
        #  because that means we're between the main run and the run(1) call
        run_status = agent.GetResultOfLastRun()
        if run_status != sml.sml_RUN_COMPLETED_AND_INTERRUPTED:
            # Set up 6 random suppliers as input for this agent run
            for i in range(6):
                input_manager.add_random_supplier()
    # EVENT 2: Before every input phaes of every decision cycle
    elif event_id == sml.smlEVENT_BEFORE_INPUT_PHASE:
        # If we want to potentially alter agent input every decision cycle, even before it sends output, we could do it here.
        # This is useful for real-time interactive environments such as robotics or games, where envirionment input can update independently from agent actions.
        print("*")

# STEP 6: Define the callback function for agent initialization
#   It should receive the agent's input manager as the user_data argument and use it to clear the agent's input suppliers.
def callback_init_agent(event_id, input_manager:MyAgentInputManager, info):
    """If anything re-initializes the agent, clear the input WMEs and local input pointers accordingly"""
    input_manager.clear_suppliers()


# STEP 8: OUTPUT CALLBACK - METHOD #1:
#   If the output attribute is 'supplier-list', pass the WME's ID to parse_supplier_list(), and print the result.
#   Then stop the agent.
#   --> Use agent.StopSelf() to stop the agent after reading the output.
def callback_output_handler(user_data, agent, attribute, wme):
    """Read any output structure labeled 'supplier-list' at the root."""
    if attribute == "supplier-list":
        out_list = parse_supplier_list(ol_list_id=wme.ConvertToIdentifier())
        if len(out_list) > 0:
            print(out_list)
        
        # Stop the agent after the output is read
        agent.StopSelf()

# STEP 10: OUTPUT CALLBACK - METHOD #2:
#   Iterate over each changed WME on the output-link.
#   If the WME is newly-added, check if it is the 'first-supplier' WME.
#   If so, pass its value ID to read_ol_supplier_list() and print the results.
#   (By directly reading the 'first-supplier' WME, we bypass calling parse_supplier_list().)
#   Stop the agent after reading output.
def callback_output_notification_event(user_data, agent):
    """Read any newly-added output-link WMEs and process the 'first-supplier' WME."""
    # Collect output from Soar
    ol_id = agent.GetOutputLink()
    if ol_id is None:
        print("No output detected during output notification event.")
        return

    # Get the output supplier list
    num_changes = agent.GetNumberOutputLinkChanges()
    # Loop through every newly-added WME (not just direct children of the output-link, but ALL descendants underneath it)
    for i in range(num_changes):
        # Check whether this event is for any newly ADDED WMEs, not just removed WMEs
        if agent.IsOutputLinkChangeAdd(i):
            changed_wme = agent.GetOutputLinkChange(i)
            attr = changed_wme.GetAttribute()
            # Detect the first-supplier WME and process it (we bypass parse_supplier_list())
            if attr == "first-supplier":
                out_list = read_ol_supplier_list(ol_supplier_id=changed_wme.ConvertToIdentifier())
                if len(out_list) > 0 and out_list[0] != "":
                    print(out_list)
    
    # Stop the agent after the output is read
    agent.StopSelf()
    
# STEP 12: OUTPUT CALLBACK - METHOD #3:
#   From the kernel, check the agent's output-link after an update.
#   If the one kernel was running multiple agents, this would be useful for checking each agent's output in one function.
def callback_output_kernel_update_event(event_id, agent_name, kernel, runtime_flags):
    """Check agent output manually when the kernel updates the output-link."""
    # Read the output-link as-is and see if its data is sufficient
    agent = kernel.GetAgent(agent_name) # (You can also use kernel.GetAgentByIndex(0), but it is slower.)
    ol_id = agent.GetOutputLink()
    if ol_id is None:
        print("No agent output available during output kernel update event.")
        return
    
    try:
        ol_list_id = ol_id.FindByAttribute("supplier-list", 0).ConvertToIdentifier()
        print(parse_supplier_list(ol_list_id))
    except AttributeError:
        print("ERROR: Output did not include supplier-list.")
    
    # Stop the agent after the output is read
    agent.StopSelf()
